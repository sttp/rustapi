var searchIndex = JSON.parse('{\
"sttp":{"doc":"Rust API for the Streaming Telemetry Transport Protocol (…","t":[3,18,18,18,18,18,18,18,18,3,3,3,18,18,11,12,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,0,11,11,11,11,12,11,12,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,12,12,12,12,12,11,11,11,12,12,12,12,11,11,12,12,11,12,11,11,11,11,11,11,11,0,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,11,12,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["Config","LEAP_SECOND_DIRECTION","LEAP_SECOND_FLAG","PER_DAY","PER_HOUR","PER_MICROSECOND","PER_MILLISECOND","PER_MINUTE","PER_SECOND","Settings","Subscriber","Ticks","UNIX_BASE_OFFSET","VALUE_MASK","add","auto_reconnect","auto_request_metadata","auto_subscribe","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","cmp","compress_metadata","compress_payload_data","compress_signal_index_cache","constraint_parameters","data","default","default","default","div","enable_time_reasonability_check","eq","extra_connection_string_parameters","fmt","fmt","from","from","from","from","from_datetime","from_duration","hash","include_time","into","into","into","into","is_leap_second","is_negative_leap_second","lag_time","lead_time","max_retries","max_retry_interval","metadata_filters","mul","now","partial_cmp","processing_interval","publish_interval","request_nan_value_filter","retry_interval","set_leap_second","set_negative_leap_second","start_time","stop_time","sub","throttled","to_datetime","to_owned","to_owned","to_owned","to_short_string","to_string","to_string","transport","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","udp_port","use_local_clock_as_real_time","use_millisecond_resolution","utc_now","version","SignalIndexCache","borrow","borrow_mut","contains","count","decode","from","id","into","new","record","signal_id","signal_ids","signal_index","source","try_from","try_into","type_id"],"q":["sttp","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","sttp::transport","","","","","","","","","","","","","","","","",""],"d":["Defines STTP connection related configuration parameters.","Flag (63rd bit) that indicates if leap second is positive …","Flag (64th bit) that marks a <code>Ticks</code> value as a leap second, …","Number of <code>Ticks</code> that occur in a day.","Number of <code>Ticks</code> that occur in an hour.","Number of <code>Ticks</code> that occur in a microsecond.","Number of <code>Ticks</code> that occur in a millisecond.","Number of <code>Ticks</code> that occur in a minute.","Number of <code>Ticks</code> that occur in a second.","Defines STTP subscription related settings.","Represents an STTP data subscriber.","Represents a 64-bit integer used to designate time in …","<code>Ticks</code> representation of the Unix epoch timestamp starting …","All bits (bits 1 to 62) that make up the value portion of …","","Defines flag that determines if connections should be …","Defines the flag that determines if metadata should be …","Defines the flag that determines if subscription should be …","","","","","","","","","","","","","","","","Determines whether the metadata transfer is compressed.","Determines whether payload data is compressed.","Determines whether the signal index cache is compressed.","include parameters that may be needed to initiate, filter, …","","","","","","Determines if publisher should perform time reasonability …","","Defines any extra custom connection string parameters that …","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Converts a standard Rust <code>DateTime</code> value to a <code>Ticks</code> value.","Converts a standard Rust <code>Duration</code> value to a <code>Ticks</code> value.","","Determines if time should be included in non-compressed, …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Determines if the deserialized <code>Ticks</code> value represents a …","Determines if the deserialized <code>Ticks</code> value represents a …","Defines the allowed past time deviation tolerance in …","Defines the allowed future time deviation tolerance in …","Defines the maximum number of times to retry a connection. …","Defines the maximum retry interval, in milliseconds. Note: …","Defines any filters to be applied to incoming metadata to …","","Gets the current local time as a <code>Ticks</code> value.","","Defines the initial playback speed, in milliseconds, for a …","Defines the down-sampling publish interval, in seconds, to …","Requests that the publisher filter, i.e., does not send, …","Defines the base retry interval, in milliseconds. Retries …","Flags a <code>Ticks</code> value to represent a leap second, i.e., …","Flags a <code>Ticks</code> value to represent a negative leap second, …","Defines the start time for a requested temporal data …","Defines the stop time for a requested temporal data …","","Determines if data will be published using down-sampling.","Converts a <code>Ticks</code> value to standard Rust <code>DateTime</code> value.","","","","Shows just the timestamp portion of a <code>Ticks</code> value with …","","Standard timestamp representation for a <code>Ticks</code> value, e.g., …","","","","","","","","","","","","","","Defines the desired UDP port to use for publication. Zero …","Determines if publisher should use local clock as real …","Determines if time should be restricted to milliseconds in …","Gets the current time in UTC as a <code>Ticks</code> value.","Defines the target STTP protocol version. This currently …","Represents a mapping of 32-bit runtime IDs to 128-bit …","","","Determines if the specified signalindex exists with the …","Gets the number of <code>Measurement</code> records that can be found …","Parses a <code>SignalIndexCache</code> from the specified byte buffer …","Returns the argument unchanged.","Returns the <code>Measurement</code> integer ID for the specified …","Calls <code>U::from(self)</code>.","Creates a new, empty <code>SignalIndexCache</code>.","Record returns the key <code>Measurement</code> values, signal ID Guid, …","Returns the signal ID Guid for the specified signalindex …","Gets a set for all the Guid values found in the …","Returns the signal index for the specified signal ID Guid …","Returns the <code>Measurement</code> source string for the specified …","","",""],"i":[0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,2,2,2,25,2,3,1,25,2,3,1,2,3,1,2,3,1,1,2,2,2,3,0,2,3,1,1,3,1,3,1,1,25,2,3,1,1,1,1,3,25,2,3,1,1,1,3,3,2,2,2,1,1,1,3,3,3,2,1,1,3,3,1,3,1,2,3,1,1,1,1,0,25,2,3,1,25,2,3,1,25,2,3,1,3,3,3,1,2,0,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[1,1],1],0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[2,2],[3,3],[1,1],[[]],[[]],[[]],[[1,1],4],0,0,0,0,0,[[],2],[[],3],[[],1],[[1,1],1],0,[[1,1],5],0,[[1,6],7],[[1,6],7],[[]],[[]],[[]],[[]],[[[9,[8]]],1],[10,1],[1],0,[[]],[[]],[[]],[[]],[1,5],[1,5],0,0,0,0,0,[[1,1],1],[[],1],[[1,1],[[11,[4]]]],0,0,0,0,[1,1],[1,1],0,0,[[1,1],1],0,[1,[[9,[12]]]],[[]],[[]],[[]],[1,13],[[],13],[1,13],0,[[],14],[[],14],[[],14],[[],14],[[],14],[[],14],[[],14],[[],14],[[],15],[[],15],[[],15],[[],15],0,0,0,[[],1],0,0,[[]],[[]],[[16,17],5],[16,18],[16,[[14,[19,[21,[20]]]]]],[[]],[[16,17],22],[[]],[[],16],[[16,17]],[[16,17],19],[16,[[23,[19]]]],[[16,19],17],[[16,17],24],[[],14],[[],14],[[],15]],"p":[[3,"Ticks"],[3,"Config"],[3,"Settings"],[4,"Ordering"],[15,"bool"],[3,"Formatter"],[6,"Result"],[8,"TimeZone"],[3,"DateTime"],[3,"Duration"],[4,"Option"],[3,"Utc"],[3,"String"],[4,"Result"],[3,"TypeId"],[3,"SignalIndexCache"],[15,"i32"],[15,"u32"],[3,"Uuid"],[8,"Error"],[3,"Box"],[15,"u64"],[3,"HashSet"],[15,"str"],[3,"Subscriber"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
